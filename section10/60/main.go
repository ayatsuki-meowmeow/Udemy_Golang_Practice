package main

import "fmt"

// ポインタ
// ポインタは値型に分類されるデータ構造のメモリ上のアドレスと型の情報のこと
// ポインタ型はメモリ上のアドレスを指し示す型

func Double(i int) {
		i = i * 2
		fmt.Println(i) // 2倍になった値が出力される
}

func DoubleV2(i *int) {
		*i = *i * 2
}

func DoubleSlice(sl []int) {
		for i, v := range sl { // スライスの要素を順番に取り出す
				sl[i] = v * 2 // スライスの要素を2倍にする
		}
}

func main() {
		var n int = 100
		fmt.Println(n) // 100

		// メモリのアドレスを表示
		fmt.Println(&n)

		Double(n) // nの値を2倍にする
		fmt.Println(n) // Doubleをしたのに、100のまま

		// int型のような基本型(値型)は、関数の引数として渡すときに値渡しになる
		// 値渡しは、関数の引数として渡した変数の値をコピーして渡すこと
		// そのため、Double関数内でnの値を変更してもnのコピーが二倍になるだけで、main関数のnの値は変更されない

		// 上記の問題を解決するには、ポインタ型を使う
		// 型名の前にアスタリスクをつけることで、ポインタ型になる
		// ポインタ型は、メモリ上のアドレスを指し示す型
		// &をつけることで、変数のアドレスを取得できる
		// &はアドレス演算子と呼ばれる
		var p *int = &n // ポインタ型の変数pを定義し、nのアドレスを代入
		fmt.Println(p) // nのアドレスが出力される
		// ポインタ型の変数の前にアスタリスクをつけると、ポインタ型の変数が指し示すアドレスの値を取得できる
		// これをデリファレンスと呼ぶ
		fmt.Println(*p) // nの値が出力される

		*p = 300 // ポインタ型の変数pが指し示すアドレスの値を変更
		// pの値が変更されたので、nの値も変更される
		fmt.Println(n) // 300

		// 逆もできる
		n = 200 // nの値を変更
		fmt.Println(*p) // nの値が変更されたので、pの値も変更される 200

		// ポインタ型を使うと、関数の引数として渡すときに参照渡しになる
		// 参照渡しは、関数の引数として渡した変数のアドレスを渡すこと(コピーしないで渡す)
		// そのため、DoubleV2関数内でnの値を変更すると、main関数のnの値も変更される
		// ポインタ型を使うことで、関数の引数として渡した変数の値を変更できる
		DoubleV2(&n) // nの値を2倍にする
		fmt.Println(n) // DoubleV2をしたので、200から400になる

		DoubleV2(p) // pの値を2倍にする
		fmt.Println(*p) // DoubleV2をしたので、pの実体は400から800になる

		// スライス、マップ、チャネルは参照型
		// 参照型は、関数の引数として渡すときに参照渡しになる
		// よって、ポインタ型を使わなくても、関数の引数として渡した変数の値を変更できる
		var sl []int = []int{1, 2, 3}
		fmt.Println(sl) // [1 2 3]

		DoubleSlice(sl) // slの値を2倍にする
		fmt.Println(sl) // DoubleSliceをしたので、[2 4 6]になる。参照渡しになっているので、main関数のslの値も変更される
}
